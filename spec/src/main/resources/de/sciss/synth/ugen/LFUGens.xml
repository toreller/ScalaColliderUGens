<ugens revision="12">
    <!-- all documented -->
    <ugen name="Vibrato">
        <rate name="control"/>
        <rate name="audio">
            <arg name="freq" rate="ugen"/>
        </rate>
        <arg name="freq" default="440.0">
            <doc>
                fundamental frequency in Hertz. If the Vibrato UGen is running at audio rate, this must
                be an audio-rate input as well.
            </doc>
        </arg>
        <arg name="beat" default="6.0">
            <doc>
                vibrato rate, that is the speed of wobble in Hertz. Note that if this is set to a too low value,
                you may never get vibrato back, since this input is only checked at the end of a cycle.
            </doc>
        </arg>
        <arg name="depth" default="0.02">
            <doc>
                amount of vibrato frequency deviation around the fundamental, as a proportion of the fundamental.
            </doc>
        </arg>
        <arg name="delay" default="0.0" init="true">
            <doc>
                delay in seconds before vibrato is established.
            </doc>
        </arg>
        <arg name="onset" default="0.0" init="true">
            <doc>
                transition time in seconds from no vibrato to full vibrato after the initial delay time.
            </doc>
        </arg>
        <arg name="beatVar" default="0.04">
            <doc>
                random (noise) variation on the beat parameter, expressed as a proportion of `beat`. It can
                change once per cycle of vibrato.
            </doc>
        </arg>
        <arg name="depthVar" default="0.1">
            <doc>
                random (noise) variation on the depth of modulation, expressed as a proportion of `depth`. It can
                change once per cycle of vibrato. The noise affects independently the up and the down part of
                vibrato shape within a cycle.
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase of vibrato modulation, allowing starting above or below the fundamental rather
                than on it.
            </doc>
        </arg>
        <doc>
            <text>
                A low frequency oscillator UGen for modelling vibrato. It produces a modulating frequency value in
                Hertz that can be used as the frequency parameter of another UGen.

                By setting more extreme settings, one
                can get back to the timbres of FM synthesis. One can also add in some noise to the vibrato rate
                and vibrato size (modulation depth) to make for a more realistic motor pattern.

                The vibrato output is a waveform based on a squared envelope shape with four stages marking out
                0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, and -1.0 back to 0.0. The vibrato rate determines how quickly
                one moves through these stages.
            </text>
            <example name="constant setting">
                SinOsc.ar(Vibrato.ar(DC.ar(400.0), 1, 0.02)) * 0.2
            </example>
            <example name="beat and beatVar mouse control">
                val beat    = MouseX.kr(2.0, 100.0)
                val beatVar = MouseY.kr(0.0, 1.0)
                val freq    = Vibrato.ar(DC.ar(400.0), beat, 0.1, 1.0, 1.0, beatVar, 0.1)
                SinOsc.ar(freq) * 0.2
            </example>
        </doc>
    </ugen>
    <ugen name="LFPulse">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase offset in cycles (`0..1`). If you think
                of a buffer of one cycle of the waveform, this is the starting offset
                into this buffer. Hence, an `iphase` of `0.25` means that you will hear
                the first impulse after `0.75` periods! If you prefer to specify the
                perceived delay instead, you could use an `iphase` of `-0.25 + 1` which
                is more intuitive. Note that the phase is not automatically wrapped
                into the range of `0..1`, so putting an `iphase` of `-0.25` currently
                results in a strange initial signal which only stabilizes to the
                correct behaviour after one period!
            </doc>
        </arg>
        <arg name="width" default="0.5">
            <doc>
                pulse width duty cycle from zero to one. If you want to
                specify the width rather in seconds, you can use the formula
                `width = freq * dur`, e.g. for a single sample impulse use
                `width = freq * SampleDur.ir`.
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited pulse oscillator UGen.
                Outputs a high value of one and a low value of zero.
            </text>
            <example name="modulating frequency">
                LFPulse.ar(XLine.kr(1, 200, 10), 0, 0.2) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPulse.kr(XLine.kr(1, 200, 10), 0, 0.2) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPulse.ar(LFPulse.kr(3, 0, 0.3).madd(200, 200), 0, 0.2) * 0.1
            </example>
            <see>ugen.Pulse</see>
        </doc>
    </ugen>
    <ugen name="LFSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase offset. For efficiency reasons this is a
                value ranging from -1 to 1 (thus equal to the initial output value).
                Note that a phase of zero (default) means the wave starts at 0 and
                rises to +1 before jumping down to -1. Use a phase of 1 to have the wave start at -1.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth oscillator UGen. The oscillator is creating an aliased sawtooth,
                that is it does not use band-limiting. For a band-limited version use
                `Saw` instead. The signal range is -1 to +1.
            </text>
            <example name="modulating frequency">
                LFSaw.ar(XLine.kr(1, 200, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFSaw.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="neuer deutscher SÃ¤gezahn">
                LFSaw.ar(LFSaw.kr(3).madd(200, 200)) * 0.1
            </example>
            <see>ugen.Saw</see>
        </doc>
    </ugen>
    <ugen name="LFPar">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase in cycle (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A sine-like oscillator UGen with a shape made of two parabolas. It has audible odd harmonics
                and is non-band-limited. Its output ranges from -1 to +1.
            </text>
            <example name="modulating frequency">
                LFPar.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPar.ar(LFPar.kr(LFPar.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
            <see>ugen.LFCub</see>
        </doc>
    </ugen>
    <ugen name="LFCub">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase in cycle (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A sine-like oscillator UGen with a shape made of two cubic pieces. It is smoother than `LFPar`.
            </text>
            <example name="modulating frequency">
                LFPar.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPar.ar(LFPar.kr(LFPar.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
            <see>ugen.LFPar</see>
        </doc>
    </ugen>
    <ugen name="LFTri">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase of the oscillator. A full phase (2 Pi or 360 degrees) is represented by
                an `iphase` value of 4. The initial phase cannot be modulated.
            </doc>
        </arg>
        <doc>
            <text>
                A triangle oscillator UGen designed for low frequency control signals (being non-band-limited).
                The output varies from -1 to 1.

                With an initial phase of zero, the oscillator begins at 0, rises to 1, then falls to -1 and goes
                back to zero after one complete phase. With an initial phase of 1 (corresponding to 90 degrees),
                the oscillator begins at 1 and then falls to -1. With an initial phase of 3 (or 270 degrees),
                the oscillator begins at -1 and then rises to 1.
            </text>
            <example name="modulating frequency">
                LFTri.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFTri.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFTri.ar(LFTri.kr(LFTri.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
        </doc>
    </ugen>
    <ugen name="LFGauss">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="dur" default="1.0">
            <doc>
                duration in seconds of a full -1 &lt;= x &lt;= 1 cycle, or the reciprocal of the frequency
            </doc>
        </arg>
        <arg name="width" default="0.1">
            <doc>
                relative width of the bell. Best to keep below 0.25 when used as envelope.
            </doc>
        </arg>
        <arg name="phase" default="0.0">    <!-- in the current implementation can be modulated! -->
            <doc>
                phase offset
            </doc>
        </arg>
        <arg name="loop" default="true">
            <doc>
                if greater than zero, the UGen oscillates. Otherwise it calls `doneAction` after one cycle.
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                evaluated after cycle completes
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited gaussian function oscillator UGen. Output ranges from `minVal` to 1. It
                implements the formula:
                {{{
                f(x) = exp((x - phase).squared / (-2 * width.squared))
                }}}
                where `x` is to vary in the range -1 to 1 over the period `dur`. `minVal` is the initial value
                at -1. E.g. for default parameters, it is `exp(-50)` or roughly zero.
            </text>
            <example name="dur and width can be modulated at audio rate">
                val dur = SinOsc.ar(MouseX.kr(2, 1000, 1) * Seq(1.0, 1.1)).linlin(-1, 1, 0.0006, 0.01)
                val width = SinOsc.ar(Seq(0.5, 0.55)).linlin(-1, 1, 0.01, 0.3)
                LFGauss.ar(dur, width) * 0.2
            </example>
            <example name="several frequencies and widths combined">
                val x    = MouseX.kr(1, 0.07, 1)
                val y    = MouseY.kr(1, 3)
                val mod  = LFGauss.ar(x, (-1 to -6 by -1).map(i => y.pow(i)))
                val carr = SinOsc.ar((0 to 5).map(i => 200 * 1.3.pow(i)))
                Mix(carr * mod) * 0.1
            </example>
            <example name="test spectrum">
                val son = LeakDC.ar(LFGauss.ar(0.005, 0.2))
                BPF.ar(son * 3, MouseX.kr(60, 2000, 1), 0.05)
            </example>
        </doc>
    </ugen>
    <ugen name="Impulse">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz. A value of zero can be used to generate a singular impulse.
            </doc>
        </arg>
        <arg name="phase" default="0.0">
            <doc>
                phase offset in cycles (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited generator UGen for single sample impulses.
            </text>
            <example name="modulating frequency">
                Impulse.ar(XLine.kr(100, 20000, 10)) * 0.3
            </example>
            <example name="modulating amplitude">
                Impulse.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.3
            </example>
            <example name="modulating phase">
                Impulse.ar(4, Seq(DC.kr(0), MouseX.kr(0, 1))) * 0.3
            </example>
            <see>ugen.LFPulse</see>
            <see>ugen.Dust</see>
            <see>ugen.Blip</see>
        </doc>
    </ugen>
    <ugen name="VarSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0">
            <doc>
                initial phase offset in cycle (0 to 1)
            </doc>
        </arg>
        <arg name="width" default="0.5">
            <doc>
                duty cycle from zero to one.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth-triangle oscillator UGen with variable duty. A `width` of zero produces a sawtooth
                of falling slope, with an initial phase of zero making it start at +1. A `width` of 0.5 produces
                a triangle wave, starting at -1 then raising to +1, then falling again to -1. A `width` of 1.0
                produces a sawtooth of rising slope, starting -1.

                Increasing the initial wave will increase the
                offset into the waveform. For example, with a phase of 0.5 and a width of 0.5, the result is
                a triangle waveform that starts at +1.

                There is a strange anomaly for the falling sawtooth (zero width): Instead of starting directly
                at +1, the first sample is -1 and only from the second sample at +1 the waveform starts falling.
                In other words, the waveform has a delay of one sample.
            </text>
            <example name="width modulation">
                val freq  = LFPulse.kr(3, 0, 0.3).madd(200, 200)
                val width = LFTri.kr(1.0).madd(0.5, 0.5)
                VarSaw.ar(freq, 0, width) * 0.2
            </example>
            <see>ugen.Saw</see>
            <see>ugen.LFSaw</see>
            <see>ugen.SyncSaw</see>
        </doc>
    </ugen>
    <ugen name="SyncSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="syncFreq" default="440.0">
            <doc>
                synchronizing (master) frequency which is the perceived fundamental
            </doc>
        </arg>
        <arg name="sawFreq" default="440.0">
            <doc>
                sawtooth (slave) frequency. It should typically be greater than `syncFreq`.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth oscillator UGen that is hard sync'ed to a fundamental pitch. That is, a sawtooth waveform
                is produced at one frequency, `sawFreq`, whereas a trigger at a another frequency, `syncFreq`, resets
                the phase of the sawtooth to zero.

                This produces an effect similar to moving formants or pulse width modulation. This is not a band
                limited waveform, so it may alias.
            </text>
            <example name="modulate saw frequency">
                SyncSaw.ar(100, Line.kr(100, 800, 12)) * 0.2
            </example>
            <see>ugen.Saw</see>
            <see>ugen.VarSaw</see>
            <see>ugen.LFSaw</see>
        </doc>
    </ugen>
    <ugen name="K2A">
        <rate name="audio" implied="true"/>
        <arg name="in">
            <doc>
                control-rate signal to convert
            </doc>
        </arg>
        <doc>
            <text>
                A converter UGen that takes a control-rate input and produces an audio-rate output by means of
                linear interpolation. The current control input value is always reached in at the beginning of
                the subsequent control block. A special case is the initialization which begins directly at the
                first control input value (therefore, the first control block of the audio-rate output is
                is always constant.)

                For example, if the block size is 64, and the first three input values are -0.5, 0.6, 0.3, then
                the output signal will be 65 samples of value -0.5, followed by a linear ramp of 64 samples
                towards 0.6, followed by a linear ramp of 64 samples to towards 0.3.
            </text>
            <example name="compare control and audio rate">
                val a = K2A.ar(WhiteNoise.kr(0.3))
                val b =        WhiteNoise.ar(0.3)
                val c = LFPulse.ar(1, Seq(0, 0.5))
                c * Seq(a, b)
            </example>
            <see>ugen.A2K</see>
            <see>ugen.T2A</see>
            <see>ugen.DC</see>
        </doc>
    </ugen>
    <ugen name="A2K">
        <rate name="control" implied="true"/>
        <arg name="in">
            <doc>
                audio-rate signal to convert
            </doc>
        </arg>
        <doc>
            <text>
                A converter UGen that takes an audio-rate input and produces a control-rate output by means of
                sampling. The sample is always taken at the beginning of each control-block, while all other
                samples of the audio-rate input within that block are ignored.
            </text>
            <!-- TODO: example -->
            <see>ugen.K2A</see>
            <see>ugen.T2K</see>
        </doc>
    </ugen>
    <ugen name="T2K">
        <rate name="control" implied="true"/>
        <arg name="in" rate="audio" type="trig">
            <doc>
                audio-rate trigger input
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that converts an audio-rate trigger input into a control-rate trigger output. A trigger
                occurs when a signal changes from less than or equal to zero to greater than zero. The UGen
                behaves strangely in that for a rising slope input signal, it will report the maximum value
                seen within the calculation block, but if the slope extends to the next block, it will output
                that second's block maximum value again instead of waiting for a fall to &lt;= 0.
            </text>
            <example name="down-sample audio-rate dust">
                val trig = T2K.kr(Dust.ar(4))
                Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
            </example>
            <see>ugen.K2A</see>
            <see>ugen.T2K</see>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="T2A">
        <rate name="audio" implied="true"/>
        <arg name="in" type="trig">
            <doc>
                control-rate trigger input
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that converts a control-rate trigger input into an audio-rate trigger output. A trigger
                occurs when a signal changes from less than or equal to zero to greater than zero. The output
                will have a single sample spike of the input trigger's amplitude at the beginning of the
                calculation block.
            </text>
            <example name="up-sample control-rate impulses">
                val trig = Impulse.kr(MouseX.kr(1, 100, 1))
                Ringz.ar(T2A.ar(trig), 800, 0.01) * 0.4
            </example>
            <see>ugen.K2A</see>
            <see>ugen.T2K</see>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="DC">
        <rate name="control"/>
        <rate name="audio"/>
        <!-- NOT: <output variadic="in"/> -->
        <arg name="in" init="true"> <!-- NOT: variadic="true" -->
            <doc>
                constant value to output, fixed at initialisation time.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that creates a constant signal at a given calculation rate.
                <!-- NOT: If the input is variadic, so will be the UGen's output (no multi-channel
                expansion needed). -->
            </text>
            <example name="create a silent audio signal">
                // Note: Select.ar requires audio-rate input.
                // Therefore, DC can be used to wrap the otherwise
                // incompatible constant zero. In future versions of
                // ScalaCollider, this wrapping will be done
                // automatically, however.
                Select.ar(MouseButton.kr(lag = 0), Seq(DC.ar(0), SinOsc.ar * 0.2))
            </example>
            <see>ugen.LeakDC</see>
        </doc>
    </ugen>
    <!--        <ugen name="Silent">
                <rate name="audio" implied="true"/>
                <output variadic="numChannels"/>
                <arg name="numChannels" type="int" default="1"/>
            </ugen> -->
    <ugen name="Line" side-effect="true" done-flag="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="start" default="0.0" init="true">
            <doc>
                Starting value
            </doc>
        </arg>
        <arg name="end" default="1.0" init="true">
            <doc>
                Ending value
            </doc>
        </arg>
        <arg name="dur" default="1.0" init="true">
            <doc>
                Duration in seconds
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                A done-action that is evaluated when the Line has reached the end value after the
                given duration
            </doc>
        </arg>
        <doc>
            <text>
                A line generator UGen that moves from a start value to the end value in a given duration.
            </text>
            <example name="pan from left to right">
                Pan2.ar(PinkNoise.ar(0.3), Line.kr(-1, 1, 10, freeSelf))
            </example>
            <see>ugen.XLine</see>
            <see>ugen.EnvGen</see>
            <see>ugen.Ramp</see>
        </doc>
    </ugen>
    <ugen name="XLine" side-effect="true" done-flag="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="start" default="1.0" init="true">
            <doc>
                Starting value
            </doc>
        </arg>
        <arg name="end" default="2.0" init="true">
            <doc>
                Ending value
            </doc>
        </arg>
        <arg name="dur" default="1.0" init="true">
            <doc>
                Duration in seconds
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                A done-action that is evaluated when the `Line` has reached the end value after the
                given duration
            </doc>
        </arg>
        <doc>
            <text>
                An exponential curve generator UGen that moves from a start value to the end value in a given duration.

                At a given point in time `0 &lt;= t &lt;= dur`, the output value is `start * (stop/start).pow(t/dur)`.

                '''Warning''': It must be ensured that the both `start` is not zero and `start` and `end` have the
                same sign (e.g. a `start` of `-1` and an end of `-0.001` are valid),
                otherwise the UGen will output a `NaN`! While in the case of `end` being zero the UGen will also
                output zero, it is recommended to treat this case as pathological as well.
            </text>
            <example name="glissando">
                SinOsc.ar(Line.kr(200, 2000, 10, freeSelf)) * 0.2
            </example>
            <see>ugen.Line</see>
        </doc>
    </ugen>

    <ugen name="Wrap">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to constrain
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                lower margin of wrapping (inclusive)
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                upper margin of wrapping (exclusive)
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that constrains a signal to a given range, by
                "wrapping" values outside the range. This is similar to
                the `wrap2` binary operator but permits both a lower
                range value `lo` and an upper range value `hi`.

                An input value greater than or equal to `hi` will be wrapped
                back to `(in - hi) % (hi - lo) + lo`. An input value less than
                `lo` will be wrapped back to `hi - (lo - in) % (hi - lo)`.
            </text>
            <example name="wrap pulse wave to modulate timbre">
                val hi = SinOsc.ar(0.1).linexp(-1, 1, 0.01, 1.0)
                Wrap.ar(Pulse.ar(300), 0, hi) * 0.2 / hi
            </example>
            <see>ugen.Fold</see>
            <see>ugen.Clip</see>
        </doc>
    </ugen>
    <ugen name="Fold">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to constrain
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                lower margin of folding
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                upper margin of folding
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that constrains a signal to a given range, by
                "folding" values outside the range. This is similar to
                the `fold2` binary operator but permits both a lower
                range value `lo` and an upper range value `hi`.

                Folding can be understood as "reflecting" around the boundaries.
                For example, if the upper margin is 3, then if an input value
                exceeds 3, the excess is negatively reflected; 3.1 becomes 2.9,
                3.2 becomes 2.8, etc. until the lower margin is reached again
                where another reflection occurs. Likewise, if the lower margin
                is 1, then if an input value falls below 1, the undershoot is
                reflected; 0.9 becomes 1.1, 0.8 becomes 1.2, etc. until the upper
                margin is reached again where another reflection occurs.
            </text>
            <example name="fold sawtooth wave to modulate timbre">
                val hi = SinOsc.ar(0.1).linexp(-1, 1, 0.01, 1.0)
                Fold.ar(Saw.ar(300), 0, hi) * 0.2 / hi
            </example>
            <see>ugen.Wrap</see>
            <see>ugen.Clip</see>
        </doc>
    </ugen>
    <ugen name="Clip">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to constrain
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                lower margin of clipping
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                upper margin of clipping
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that constrains a signal to a given range, by
                limiting values outside the range to the range margins. This is similar to
                the `clip2` binary operator but permits both a lower
                range value `lo` and an upper range value `hi`.

                Mathematically, this is equivalent to `in.max(lo).min(hi)`.

                Be aware that there seems to be an initialization bug.
                The following crashes, indicating that `Clip.ar` outputs a zero initially:

                {{
                play {
                    val bar = Integrator.ar(DC.ar(0), coeff = 0.999)
                    val foo = Clip.ar(bar, lo = 1.0, hi = 44100.0) // .max(1.0)
                    val sum = RunningSum.ar(DC.ar(0), length = foo)
                    sum.poll(1, "sum")
                    ()
                }
                }}
            </text>
            <example name="clip sine wave to modulate timbre">
                val hi = SinOsc.ar(0.1).linexp(-1, 1, 0.01, 1.0)
                Clip.ar(SinOsc.ar(300), 0, hi) * 0.2 / hi
            </example>
            <see>ugen.Wrap</see>
            <see>ugen.Fold</see>
        </doc>
    </ugen>
    <!-- this should exist according to plugin sources...
    <ugen name="Unwrap"/>
    -->
    <ugen name="AmpComp">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="freq" rate="ugen"/>
        </rate>
        <arg name="freq" default="261.626">
            <doc>
                the frequency in Hertz for which to determine the compensation factor
            </doc>
        </arg>
        <arg name="root" default="261.626">
            <doc>
                the base frequency corresponding to a compensation factor of 1.0
            </doc>
        </arg>
        <arg name="expon" default="0.3333">
            <doc>
                the exponent determines how steep the compensation curve decreases for
                increasing frequencies. In general, the louder a signal is played,
                the shallower the equal loudness contours become.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that produces a psychoacoustic amplitude compensation factor for
                a given frequency.

                Implements the formula: `(root / freq).pow(exp)`

                Higher frequencies are normally perceived as louder, therefore `AmpComp` outputs
                lower values for them. For example, with default parameters, the pitch C4
                (frequency 262 Hz) produces the base factor of 1.0, whereas a pitch one octave up,
                C5 (or 523 Hz) produces a factor of 0.793719 (an attenuation of -2 dB).

                An alternative is `AmpCompA` that better models the bell-shaped equal loudness
                contours of the hearing system. Especially note that the output of this UGen can
                become very high for frequencies much lower than the `root` parameter.
            </text>
            <example name="activate with mouse button">
                val freq = MouseX.kr(300, 15000, 1)
                val mod  = freq * SinOsc.ar(MouseY.kr(3, 200, 1)).madd(0.5, 1)
                val corr = AmpComp.ar(mod, 300) * 2
                val amp  = Select.ar(MouseButton.kr(lag = 0), Seq(DC.ar(1), corr))
                SinOsc.ar(mod) * 0.1 * amp
            </example>
            <see>ugen.AmpCompA</see>
        </doc>
    </ugen>
    <ugen name="AmpCompA">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="freq" rate="ugen"/>
        </rate>
        <arg name="freq" default="1000.0">
            <doc>
                the frequency in Hertz for which to determine the compensation factor
            </doc>
        </arg>
        <arg name="root" default="0.0" init="true">
            <doc>
                the root frequency in Hertz, relative to which the curve is calculated. This is
                usually lowest expected frequency.
            </doc>
        </arg>
        <arg name="minAmp" default="0.32" init="true">
            <doc>
                amplitude at the minimum point of the curve. This is the factor
                output when `freq` is approx. 2512 Hz.
            </doc>
        </arg>
        <arg name="rootAmp" default="1.0" init="true">
            <doc>
                amplitude at the root frequency of the curve. This is the factor
                output when `freq == root`.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that produces a psychoacoustic amplitude compensation factor for
                a given frequency. It uses the A-weighting curve that is based on the
                Fletcher-Munson curve for rather low volume sounds (40 phon).

                Only the `freq` parameter can be modulated, the other parameters are read at
                initialization time only.
            </text>
            <example name="activate with mouse button">
                val freq = MouseX.kr(300, 15000, 1)
                val mod  = freq * SinOsc.ar(MouseY.kr(3, 200, 1)).madd(0.5, 1)
                val corr = AmpCompA.ar(mod, 300) * 2
                val amp  = Select.ar(MouseButton.kr(lag = 0), Seq(DC.ar(1), corr))
                SinOsc.ar(mod) * 0.1 * amp
            </example>
            <see>ugen.AmpComp</see>
        </doc>
    </ugen>
    <ugen name="InRange">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to test
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                lower margin of test range (inclusive)
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                upper margin of test range (inclusive)
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that tests if a signal is within a given range. If `in &gt;= lo` and `in &lt;= hi`, outputs 1.0,
                otherwise outputs 0.0.
            </text>
            <example name="detect whether mouse is in specific horizontal range">
                val x = MouseX.kr
                InRange.kr(x, 0.4, 0.6) * PinkNoise.ar(0.3)
            </example>
            <see>ugen.InRect</see>
            <see>ugen.Clip</see>
            <see>ugen.Schmidt</see>
        </doc>
    </ugen>
    <ugen name="InRect">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="x">
            <doc>
                "horizontal" signal to test
            </doc>
        </arg>
        <arg name="y">
            <doc>
                "vertical" signal to test
            </doc>
        </arg>
        <arg name="left" default="0.0">
            <doc>
                lower margin of horizontal test range (inclusive)
            </doc>
        </arg>
        <arg name="top" default="0.0">
            <doc>
                lower margin of vertical test range (inclusive)
            </doc>
        </arg>
        <arg name="right" default="1.0">
            <doc>
                upper margin of horizontal test range (inclusive)
            </doc>
        </arg>
        <arg name="bottom" default="1.0">
            <doc>
                upper margin of vertical test range (inclusive)
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that tests if two signals lie both within a given ranges. The two input signals can be
                understood as horizontal and vertical coordinates, therefore the test become one that
                determines whether the input is within a given "rectangle".

                If `x &gt;= left` and `x &lt;= right` and `y &gt; top` and `y &lt;= bottom`, outputs 1.0,
                otherwise outputs 0.0.
            </text>
            <example name="detect whether mouse is in specific horizontal and vertical range">
                val x  = MouseX.kr; val y = MouseY.kr(1, 0)
                val in = InRect.kr(x = x, y = y, left = 0.4, top = 0.2, right = 0.6, bottom = 0.4)
                in * PinkNoise.ar(0.3)
            </example>
            <see>ugen.InRange</see>
            <see>ugen.Clip</see>
        </doc>
    </ugen>
    <ugen name="LinExp"> <!-- XXX TODO: first arg rate has to be rate ? -->
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to convert
            </doc>
        </arg>
        <arg name="srcLo" default="0.0">
            <doc>
                lower limit of input range
            </doc>
        </arg>
        <arg name="srcHi" default="1.0">
            <doc>
                upper limit of input range
            </doc>
        </arg>
        <arg name="dstLo" default="1.0">
            <doc>
                lower limit of output range
            </doc>
        </arg>
        <arg name="dstHi" default="2.0">
            <doc>
                upper limit of output range
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which maps a linear range to an exponential range.
                The equivalent formula is `(dstHi / dstLo).pow((in - srcLo) / (srcHi - srcLo)) * dstLo`.

                '''Note''': No clipping is performed. If the input signal exceeds the input range,
                the output will also exceed its range.
            </text>
            <example name="translate linear noise into exponential frequencies">
                val mod = LFNoise2.ar(10)
                val lo  = MouseX.kr(200, 8000, 1)
                val hi  = MouseY.kr(200, 8000, 1)
                SinOsc.ar(LinExp.ar(mod, -1, 1, lo, hi)) * 0.1
            </example>
            <see>ugen.LinExp</see>
            <see>ugen.Clip</see>
        </doc>
    </ugen>
    <!--        <ugen name="LinLin">
                <rate name="scalar"/>
                <rate name="control"/>
                <rate name="audio"/>
                <arg name="in" rate="ugen">
                    <doc>
                        The input signal to convert.
                    </doc>
                </arg>
                <arg name="srcLo" default="0">
                    <doc>
                        The lower limit of input range.
                    </doc>
                </arg>
                <arg name="srcHi" default="1">
                    <doc>
                        The upper limit of input range.
                    </doc>
                </arg>
                <arg name="dstLo" default="0">
                    <doc>
                        The lower limit of output range.
                    </doc>
                </arg>
                <arg name="dstHi" default="1">
                    <doc>
                        The upper limit of output range.
                    </doc>
                </arg>
                <doc>
                    <text>
                        A UGen which maps a linear range to another linear range.
                        The equivalent formula is `(in - srcLo) / (srcHi - srcLo) * (dstHi - dstLo) + dstLo`.

                        '''Note''': No clipping is performed. If the input signal exceeds the input range, the output will also exceed its range.
                    </text>
                    <see>ugen.LinExp</see>
                    <see>ugen.Clip</see>
                </doc>
            </ugen>
    -->
    <ugen name="EnvGen" side-effect="true" done-flag="true">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="gate" default="open" pos="1">  <!-- negative values have special meaning, though... -->
            <doc>
                triggers the envelope and holds it open while greater than zero. If the envelope is of
                fixed duration (e.g. `Env.linen`, `Env.perc`), the `gate` argument is used as a simple trigger.
                If it contains a sustained segment (e.g. `Env.adsr`, `Env.asr`), the envelope is held open until
                the gate becomes 0, at which point is released. If `gate` is less than zero, a release is
                enforced with duration `-1.0 - gate`.
            </doc>
        </arg>
        <arg name="levelScale" default="1.0" pos="2">  <!-- like init="true" but can be re-triggered... -->
            <doc>
                amplitude factor with which the nominal envelope is multiplied.
            </doc>
        </arg>
        <arg name="levelBias" default="0.0" pos="3">
            <doc>
                amplitude offset which is added to the nominal envelope.
            </doc>
        </arg>
        <arg name="timeScale" default="1.0" pos="4">
            <doc>
                time scale factor with which the envelope segment durations are multiplied.
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing" pos="5">
            <doc>
                action to be performed when the envelope reaches its end point.
            </doc>
        </arg>
        <arg name="envelope" variadic="true" pos="0">
            <doc>
                the description of the envelope break-points. Typically you pass an instance of `Env` which
                will then automatically expand to the correct format.
            </doc>
        </arg>
        <doc>
            <text>
                An envelope generator UGen. It uses a break point description in its `envelope` input, typically
                coming from an `Env` object. The envelope may be re-triggered using the `gate` input. Upon start
                and upon re-triggering, the `envelope`, `levelScale`, `levelBias` and `timeScale` parameters are
                polled and remain constant for the duration of the envelope.

                To construct a manual envelope without the use of the `Env` class, the format should be as
                follows:

                {{{
                val env = Seq[GE](startLevel, numSegments, releaseNode, loopNode,
                                  targetLevel1, duration1, curveType1, curvature1,
                                  targetLevel2, duration2, curveType2, curvature2,
                                  ...)
                }}}

                Where the curve-type is one of `Curve.step.id`, `Curve.lin.id`, `Curve.exp.id`, etc. The
                curvature values are only relevant for the parametric curve type. The `releaseNode` and
                `loopNode` parameters are segment indices or the special value `-99` indicating that there
                are no release or loop segments.

                '''Note''': The actual minimum duration of a segment is not zero, but one sample step for audio
                rate and one block for control rate. This may result in asynchronicity when in two envelopes of
                different number of levels, the envelope times add up to the same total duration. Similarly, when
                modulating times, the new time is only updated at the end of the current segment; this may lead to
                asynchronicity of two envelopes with modulated times.
            </text>
            <example name="percussive one-shot">
                PinkNoise.ar(EnvGen.kr(Env.perc, doneAction = freeSelf))
            </example>
            <example name="fixed duration amplitude envelope">
                val env = Env(0, Seq(0.01 -> 1, 0.5 -> 0.5, 0.02 -> 1, 0.5 -> 0))
                SinOsc.ar(470) * EnvGen.kr(env, doneAction = freeSelf)
            </example>
            <example name="amplitude and frequency modulation">
                val env  = Env(0, Seq(0.01 -> 1, 0.5 -> 0.5, 0.02 -> 0.8, 0.5 -> 0, 0.2 -> 1.2, 0.5 -> 0))
                val gate = Impulse.kr(MouseX.kr(0.2, 3), 0.5)
                val gen  = EnvGen.kr(env, gate)
                SinOsc.ar(270, SinOsc.ar(gen * 473)) * gen * 0.2
            </example>
            <example name="Dust-triggered envelope">
                val c   = Curve.parametric(-4)
                val env = Env(0, Seq((0.05,0.5,c), (0.1,0.0,c), (0.01,1.0,c), (1.0,0.9,c), (1.5,0.0,c)))
                val gen = EnvGen.ar(env, Dust.ar(1))
                SinOsc.ar(gen * 1000 + 440) * gen * 0.1
            </example>
            <example name="two channels">
                val p = Curve.parametric(-4)

                def mkEnv(a: Double, b: Double) = {
                  val env = Env(0.0, Seq((0.05,a,p), (0.1,0.0,p), (0.01,1.0,p), (1.0,b,p), (1.5,0.0,p)))
                  EnvGen.ar(env, Dust.ar(1))
                }

                val gen: GE = Seq(mkEnv(-0.2, -0.4), mkEnv(0.5, 0.9))
                SinOsc.ar(gen * 440 + 550) * gen * 0.1
            </example>
            <example name="control gate and done-action" type="full">
                val x = play {
                  var gen = EnvGen.kr(Env.adsr(), "gate".kr(0), doneAction = "done".kr(0))
                  SinOsc.ar(440) * gen * 0.1
                }

                x.set("gate" -> 1)  // turn on
                x.set("gate" -> 0)  // turn off
                x.set("gate" -> 1)  // turn on
                x.set("done" -> freeSelf.id, "gate" -> 0) // turn off and free
            </example>
            <example name="fast triggering">
                val freq = MouseX.kr(1, 100, 1)
                val gate = Impulse.ar(freq)
                val env  = Env.perc(0.1, 0.9)
                val gen  = EnvGen.ar(env, gate = gate, timeScale = freq.reciprocal)
                SinOsc.ar(440) * gen * 0.1
            </example>
            <see>ugen.Env</see>
            <see>ugen.IEnvGen</see>
            <see>ugen.Line</see>
            <see>ugen.XLine</see>
            <see>ugen.Linen</see>
            <see>ugen.Decay</see>
        </doc>
    </ugen>
    <ugen name="Linen" side-effect="true" done-flag="true">
        <rate name="control"/>
        <!-- NOT SUPPORTED: <rate name="audio"/> -->
        <arg name="gate" default="open">
            <doc>
                triggers the envelope and holds it open while greater than zero. A value of less than zero
                enforces a release with duration `-1.0 - gate`.
            </doc>
        </arg>
        <arg name="attack" default="0.01">
            <doc>
                duration (seconds) of the attack segment
            </doc>
        </arg>
        <arg name="sustain" default="1.0">
            <doc>
                level of the sustain segment
            </doc>
        </arg>
        <arg name="release" default="1.0">
            <doc>
                duration (seconds) of the release segment
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                action to be performed when the envelope reaches its end point.
            </doc>
        </arg>
        <doc>
            <text>
                A linear ASR-type envelope generator UGen.
            </text>
            <example name="repeated trigger">
                val gen = Linen.kr(Impulse.kr(2), 0.01, 0.6, 1.0)
                SinOsc.ar(440) * gen * 0.1
            </example>
            <example name="play once and end the synth">
                val gen = Linen.kr(Impulse.kr(0), 0.01, 0.6, 1.0, doneAction = freeSelf)
                SinOsc.ar(440) * gen * 0.1
            </example>
            <example name="play once and sustain" type="full">
                val x = play {
                  val gen = Linen.kr("gate".kr(1), 0.01, 0.6, 1.0, doneAction = freeSelf)
                  SinOsc.ar(440) * gen * 0.1
                }

                x.release(4)    // release envelope with given duration
            </example>
            <example name="longer gate to sustain for a given duration">
                val gate = Trig.kr(1, dur = 2)
                val gen = Linen.kr(gate, 0.01, 0.6, 1.0, doneAction = freeSelf)
                SinOsc.ar(440) * gen * 0.1
            </example>
            <see>ugen.EnvGen</see>
        </doc>
    </ugen>
    <ugen name="IEnvGen">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="index" pos="1">  <!-- default="1.0" -->
            <doc>
                index point into the envelope, given as time in seconds
            </doc>
        </arg>
        <arg name="envelope" variadic="true" pos="0">
            <doc>
                the description of the envelope break-points. Typically you pass an instance of `IEnv` which
                will then automatically expand to the correct format.
            </doc>
        </arg>
        <doc>
            <text>
                Envelope generator UGen with random access index pointer into the break-point function.

                '''Warning''': The envelope must be generated using `IEnv` not `Env`. `IEnv` has a completely
                different format. Using the wrong format (`Env`) may crash the server.

                To construct a manual envelope without the use of the `IEnv` class, the format should be as
                follows:

                {{{
                val env = Seq[GE](offset, startLevel, numSegments, totalDuration,
                  duration1, curveType1, curvature1, targetLevel1,
                  duration2, curveType2, curvature2, targetLevel2
                  ...)
                }}}
            </text>
            <example name="mouse controls index">
                import Curve._
                val env = IEnv(0, Seq(
                  (0.10, 0.6, lin),
                  (0.02, 0.3, exp),
                  (0.40, 1.0, parametric(-6)),
                  (1.10, 0.0, sine)))
                val dur = Mix(env.segments.map(_.dur))
                val gen = IEnvGen.kr(env, MouseX.kr(0, dur))
                SinOsc.ar(gen * 500 + 440) * 0.2
            </example>
            <see>ugen.IEnv</see>
            <see>ugen.EnvGen</see>
        </doc>
    </ugen>
</ugens>